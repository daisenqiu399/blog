---
updateTime: "2024-12-01 23:39"
desc: "在面试各个公司遇到的问题总结"
tags: "面试"
outline: deep
---
# 实在智能一面

## 什么时候学JavaScript的

大一，字节跳动青训营

## A对象为空，B对象不为空，A怎么访问B里面的属性

- 如果`A`对象为空（假设这里的空是指没有任何属性），可以将`B`对象的属性赋值给`A`，然后通过`A`来访问。

```js
let A = {};
let B = {
  prop1: "value1",
  prop2: "value2"
};
// 将B的属性赋值给A
A.prop1 = B.prop1;
A.prop2 = B.prop2;
console.log(A.prop1); 
console.log(A.prop2); 
```

**使用 Object.assign () 方法**

- `Object.assign()`方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。

- ```js
  let A = {};
  let B = {
    prop1: "value1",
    prop2: "value2"
  };
  Object.assign(A, B);
  console.log(A.prop1); 
  console.log(A.prop2); 
  ```

  **使用扩展运算符（...）（ES6 及以上）**

  扩展运算符可以用于浅拷贝对象的属性

  ```js
  let A = {};
  let B = {
    prop1: "value1",
    prop2: "value2"
  };
  A = {...B };
  console.log(A.prop1); 
  console.log(A.prop2); 
  ```

  

  

  

## 原型链怎么实现

1. **原型链的基本概念**

   在 JavaScript 中，每个对象都有一个内部属性`[[Prototype]]`（在大多数浏览器中可以通过`__proto__`属性访问，虽然这并不是标准属性，但被广泛支持），这个属性指向该对象的原型对象。当访问一个对象的属性时，如果在该对象本身找不到这个属性，JavaScript 会自动沿着`[[Prototype]]`指向的原型对象去查找，这个查找过程会持续进行，形成一个类似链条的结构，这就是原型链。

   **函数和原型对象的关系**

   函数在 JavaScript 中有一个特殊的属性`prototype`，这个`prototype`属性所指向的对象就是通过该函数创建的实例对象的原型对象。例如：

   ```js
   function Person() {
     // 构造函数体
   }
   let person = new Person();
   console.log(person.__proto__ === Person.prototype); 
   ```

   **使用原型链实现继承**

   基于原型链可以实现继承。例如，在上面的`Dog`和`Animal`例子中，`Dog`继承了`Animal`的属性`species`。

   再看一个更复杂的例子：

   ```js
   function Shape() {
     this.name = 'Shape';
   }
   Shape.prototype.draw = function() {
     console.log('Drawing a shape');
   };
   function Circle() {
     this.type = 'Circle';
   }
   Circle.prototype = new Shape();
   Circle.prototype.constructor = Circle;
   let myCircle = new Circle();
   myCircle.draw(); 
   ```

   

## this指向问题

🚩在JavaScript中，this关键字指向函数执行时的当前对象。this的指向取决于函数调用的方式，而不是函数定义的位置。

🚩在全局作用域中，this指向全局对象（在浏览器中是window对象，在Node.js中是global对象）。
🚩在函数调用中，如果函数不是作为对象的方法被调用，那么this指向全局对象。
🚩在作为对象方法调用时，this指向调用该方法的对象。
🚩在构造函数中，this指向新创建的对象。
🚩在事件处理程序中，this指向触发事件的元素。
🚩此外，可以使用call()、apply()和bind()方法显式地设置函数调用时的this值。

```js
// 1.在全局作用域中，this指向全局对象：
console.log(this === window); // 输出true（在浏览器中）

// 2.在函数调用中，如果函数不是作为对象的方法被调用，那么this指向全局对象：
function foo() {
    console.log(this === window); // 输出true（在浏览器中）
}
foo();

// 3.在作为对象方法调用时，this指向调用该方法的对象：
let obj = {
    myMethod: function() {
        console.log(this === obj); // 输出true
    }
};
obj.myMethod();

// 4.在构造函数中，this指向新创建的对象：
function MyConstructor() {
    this.myProperty = 'Hello World!';
    console.log(this instanceof MyConstructor); // 输出true
}
let myInstance = new MyConstructor();

// 5.在事件处理程序中，this指向触发事件的元素：
<button id="myButton">点击!</button>
<script>
    let button = document.getElementById('myButton');
    button.onclick = function() {
        console.log(this === button); // 输出true
    };
</script>

// 6.使用call()、apply()和bind()方法显式地设置函数调用时的this值：
function foo() {
    console.log(this);
}
let obj = { a: 1 };
foo.call(obj); // 输出{ a: 1 }
foo.apply(obj); // 输出{ a: 1 }
let bar = foo.bind(obj);
bar(); // 输出{ a: 1 }
```



在严格模式下，如果函数不是作为对象的方法被调用，那么this的值为undefined。
在DOM事件处理程序中，如果使用addEventListener()方法添加事件处理程序，那么事件处理程序中的this指向触发事件的元素。但是，如果使用attachEvent()方法（仅在旧版本的IE中可用），那么事件处理程序中的this指向全局对象。
在回调函数中，this的指向取决于回调函数被调用的方式。例如，在setTimeout()和setInterval()中，回调函数中的this指向全局对象。在数组方法（如forEach()、map()、filter()等）中，回调函数中的this指向全局对象，除非显式地设置了thisArg参数。
在箭头函数中，this的值取决于箭头函数定义时所在的上下文。箭头函数不会创建自己的this值，而是从外层作用域继承this值。
如果使用了ES6的类语法，那么类中的方法默认是在严格模式下执行的，因此类方法中的this指向取决于方法调用的方式。

```js
// 1.在严格模式下，函数调用中的this指向undefined：
'use strict';
function foo() {
    console.log(this);
}
foo(); // 输出undefined

// 2.在DOM事件处理程序中，使用addEventListener()方法添加事件处理程序，事件处理程序中的this指向触发事件的元素：
<button id="myButton">Click me!</button>
<script>
    let button = document.getElementById('myButton');
    button.addEventListener('click', function() {
        console.log(this); // 输出<button id="myButton">Click me!</button>
    });
</script>

// 3.在回调函数中，this的指向取决于回调函数被调用的方式：
// 在setTimeout()中，回调函数中的this指向全局对象
setTimeout(function() {
    console.log(this === window); // 输出true（在浏览器中）
}, 1000);

// 在数组方法中，回调函数中的this指向全局对象，除非显式地设置了thisArg参数
let arr = [1, 2, 3];
arr.forEach(function() {
    console.log(this === window); // 输出true（在浏览器中）
});
arr.forEach(function() {
    console.log(this === obj);
}, obj); // 输出true

// 4.在箭头函数中，this的值取决于箭头函数定义时所在的上下文：
let obj = {
    myMethod: function() {
        let arrowFunction = () => {
            console.log(this === obj); // 输出true
        };
        arrowFunction();
    }
};
obj.myMethod();

// 5.在类方法中，this指向取决于方法调用的方式：
class MyClass {
    myMethod() {
        console.log(this);
    }
}
let myInstance = new MyClass();
myInstance.myMethod(); // 输出MyClass实例
let myMethod = myInstance.myMethod;
myMethod(); // 输出undefined（在严格模式下）或全局对象（在非严格模式下）
```



## **箭头函数和普通函数的区别**

- 箭头函数是普通函数的简写，但是它不具备很多普通函数的特性
- this指向问题，箭头函数的this指向它定义时所在的对象，而不是调用时所在的对象
- 箭头函数没有独立的 this、argument 和super，并且不可被用作方法。
- 不会进行函数提升
- 不能new
- 箭头函数不能用作构造函数，当使用 new 调用时会出错。它们也没有 prototype 属性。

## typeof 和instance

🍓1、 typeof：typeof操作符可以返回一个字符串，表示未经计算的操作数的类型。优点在于它简单易用，可以快速检测基本数据类型。但它也有一些缺点，例如它无法区分Object、Array和Null，因为都会返回"object"。

🍓2、 instanceof：instanceof操作符主要用于检测引用数据类型，它用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。因此，它并不适用于检测所有数据类型。优点在于它可以检测引用数据类型，判断一个实例是否属于某个类。但它也有一些缺点，例如它无法检测基本数据类型。

```js
console.log([] instanceof Array); // 输出true
console.log({} instanceof Object); // 输出true
```



## 链表和数组

- 数组

  数组是一种线性的数据结构，它在内存中是连续存储的。可以把数组想象成一排紧密排列的盒子，每个盒子都有一个固定的编号（索引），从 0 开始。例如，`int[] array = {1, 2, 3, 4, 5};`这个整型数组，它在内存中有一段连续的空间，`array[0]`存储 1，`array[1]`存储 2，以此类推。

  数组的大小在创建时通常是固定的，这意味着如果要增加或减少数组的容量，可能需要重新分配内存并复制数据。例如，在 Java 中，如果要扩展一个数组的长度，需要创建一个新的、更大的数组，然后将原数组中的元素复制到新数组中。

- 链表

  链表是由一系列节点组成的数据结构。每个节点包含两个部分：数据部分和指向下一个节点的指针（在单向链表中）。可以把链表想象成一条链子，每个链环就是一个节点。例如，一个简单的链表节点结构可以定义为：

## 排序算法

```js
// 定义数组
let arr = [1, 2, 3, 4, 8, 9, 7];

// 外层循环控制比较轮数，一共需要比较数组长度 - 1轮
for (let i = 0; i < arr.length - 1; i++) {
    // 内层循环控制每一轮比较的次数，每一轮比较次数会逐渐减少
    for (let j = 0; j < arr.length - 1 - i; j++) {
        // 如果当前元素大于下一个元素，则交换它们的位置
        if (arr[j] > arr[j + 1]) {
            // 使用解构赋值进行元素交换
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
    }
}

console.log(arr);
```



## React hooks和类的区别

1. 语法和使用方式

   类（Class）

   类组件是基于 ES6 的`class`语法来定义的。它需要继承`React.Component`类，并且有一个`render`方法来返回要渲染的内容。例如：

```js
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
  handleClick = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1
    }));
  }
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

- 在类组件中，通过`this.state`来访问和管理状态，使用`this.setState`方法来更新状态。生命周期方法（如`componentDidMount`、`componentWillUnmount`等）是通过在类中定义特定的方法来实现的，这些方法会在组件的不同生命周期阶段自动被调用。

- Hooks
- Hooks 是函数，它允许你在不使用类的情况下使用 React 的特性。例如，使用`useState`和`useEffect`来管理状态和副作用。以一个简单的计数器为例：

```js
import React, { useState } from 'react';
function MyComponent() {
  const [count, setCount] = useState(0);
  const handleClick = () => {
    setCount(count + 1);
  };
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

- `useState`是一个 Hook，它返回一个数组，数组的第一个元素是状态值（这里是`count`），第二个元素是用于更新状态的函数（这里是`setCount`）。`useEffect`等其他 Hooks 的使用方式也类似，它们以函数的形式被调用，并且在函数组件内部执行相关的逻辑。



# 上海飞未一面

## 代码题

```js
for(var i=1;i<5;i++){
    console.log(i);
}
//输出1，2，3，4

for(var i=1;i<5;i++){
    setTimeout(function(){
        console.log(i);
},i*1000);
}
//输出，5，5，5，5
//当 for 循环结束时，i 的值已经变成了 5（因为最后一次满足 i < 5 条件进入循环体后，i 会自增到 5，然后循环结束）。此时，之前在每次循环中添加到任务队列里的 setTimeout 回调函数开始依次执行，而它们访问的 i 变量是同一个（由于 var 的作用域特性），这个 i 的值已经变成了 5，所以每个回调函数执行时输出的都是 5，最终就会输出四个 5。
for(let i=1;i<5;i++){
    setTimeout(function(){
        console.log(i);
},i*1000);
}

//每隔 1 秒依次输出 1，2，3，4，let具有块级作用域
for(var i=1;i<5;i++){
    (function(j){
        setTimeout(function(){
            console.log(j);
        },j*1000)；
    })(i)
}
//这段代码会每隔 1 秒依次输出 1、2、3、4，以下是具体的分析过程：
/*代码执行逻辑分析
for循环部分：
这里使用var关键字声明了循环变量i，var声明的变量存在变量提升且作用域是函数级别的（在当前函数内都有效，如果在全局环境下声明就在全局有效）。循环从i = 1开始，每次i自增1，只要i小于5，就会执行循环体中的代码。
立即执行函数表达式（IIFE）部分：
在循环体中，定义了一个立即执行函数表达式(function(j){...})(i)，这其实就是利用了闭包的原理。
每次循环时，会把当前i的值作为参数传递给这个立即执行函数（形参为j），立即执行函数会立即执行，在其内部又定义了一个setTimeout定时器。
关键在于，这个立即执行函数形成了一个闭包环境，它内部的j参数值会被封闭在这个独立的作用域内，不会受到外部循环变量i后续变化的影响。
setTimeout回调函数部分：
setTimeout的回调函数内部访问的j，就是来自于它所在的那个立即执行函数的参数。由于每次循环传递进来的j值是不同的（第一次循环传递进来的j值为1，第二次为2，以此类推），并且闭包保证了每个setTimeout回调函数能访问到对应的正确的j值。*/
```



## css实现一个实心三角形

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solid Triangle with Border</title>
    <style>
        /* 定义向下的实心三角形样式 */
      .triangle-down {
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-top: 100px solid red;
            margin: 50px auto; /* 让三角形在页面中水平居中显示，可根据需要调整 */
        }

        /* 定义向上的实心三角形样式 */
      .triangle-up {
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 100px solid green;
            margin: 50px auto;
        }

        /* 定义向左的实心三角形样式 */
      .triangle-left {
            width: 0;
            height: 0;
            border-top: 50px solid transparent;
            border-bottom: 50px solid transparent;
            border-right: 100px solid blue;
            margin: 50px auto;
        }

        /* 定义向右的实心三角形样式 */
      .triangle-right {
            width: 0;
            height: 0;
            border-top: 50px solid transparent;
            border-bottom: 50px solid transparent;
            border-left: 100px solid orange;
            margin: 50px auto;
        }
    </style>
</head>

<body>
    <!-- 使用类名为triangle-down的元素展示向下的实心三角形 -->
    <div class="triangle-down"></div>
    <!-- 使用类名为triangle-up的元素展示向上的实心三角形 -->
    <div class="triangle-up"></div>
    <!-- 使用类名为triangle-left的元素展示向左的实心三角形 -->
    <div class="triangle-left"></div>
    <!-- 使用类名为triangle-right的元素展示向右的实心三角形 -->
    <div class="triangle-right"></div>
</body>

</html>
```



## 分析大屏布局

## 常用的html标签

## 回流和重绘

## vue2+vue3的区别

**Vue 2**：

使用`Object.defineProperty()`来进行数据劫持，实现响应式。它会遍历对象的属性，通过`defineProperty`方法将属性转换为访问器属性（getter 和 setter）

**Vue  3**：

采用`Proxy`来实现响应式。`Proxy`可以代理整个对象，而不仅仅是对象的属性。



**Vue 2**：

有许多选项用于定义组件，如`data`、`computed`、`methods`、`watch`等。`data`选项必须是一个函数，返回一个对象，这个对象中的属性会被转换为响应式数据

**Vue 3：**

组件选项的概念仍然存在，但在语法和一些细节上有所变化。`setup`函数成为了新的核心概念，用于组合逻辑。在`setup`函数中，可以使用`ref`和`reactive`来创建响应式数据

**Vue 2**：

模板语法相对比较直观，通过双大括号`{{}}`来进行数据绑定，如`{{ count }}`。对于事件绑定，使用`v - on`指令（缩写为`@`），如`@click="increment"`。指令的语法比较固定，例如`v - if`、`v - for`等指令用于条件渲染和循环渲染

**Vue 3**：

模板语法在大体上和 Vue 2 相似，但在一些细节上可能会因为响应式的变化而有所不同。例如，在访问`ref`创建的响应式数据时，需要使用`value`，如`count.value`。不过在实际开发中，在模板中访问`ref`数据时，这个`value`会被自动处理，开发人员不需要总是显式地写`value`。指令的使用和 Vue 2 基本一致，但在性能和一些内部实现细节上可能会有优化



**Vue 2**

提供了一些性能优化的手段，如`keep - alive`组件，用于缓存组件的状态，避免组件频繁地重新创建和销毁。`v - show`和`v - if`指令可以根据实际需求选择使用，`v - show`是通过控制元素的`display`属性来实现显示和隐藏，而`v - if`是真正的条件渲染，会在条件不满足时将元素从 DOM 中移除，开发者需要根据具体场景选择合适的指令来优化性能。另外，`shouldComponentUpdate`生命周期钩子可以用于手动控制组件是否重新渲染，通过比较`nextProps`和`nextState`与当前的`props`和`state`来决定是否更新组件。

**Vue 3**

在性能方面有了进一步的优化。静态提升是 Vue 3 的一个重要优化点，它会在编译阶段将模板中的静态节点提升出来，避免在每次渲染时都重新创建这些节点，从而提高渲染效率。同时，`PatchFlag`机制可以更精确地追踪和更新动态节点，减少不必要的 DOM 操作。另外，`Vue 3`的响应式系统基于`Proxy`的特性也使得在一些情况下性能更好，例如在处理大量数据的更新时，`Proxy`可以更高效地检测变化。



## **常用的组件库**

element plus和ant/design

