---
updateTime: "2025-3-12 21:24"
desc: "前端常见的手写题"
tags: "场景题"
outline: deep
---
## 前端手写场景题

### **TodoList(React)**

```js
import { useState } from "react"

function tolist(){
    const [tasks,setTasks]=useState(["eat breakfast",'play basketball','play game','watch tiktok','weChat'])
    const [newTask,setNewTask]=useState("")
    function handleInputChange(event){
        setNewTask(event.target.value)

    }

    function addTask(){
        if(newTask.trim()!==""){
            setTasks(t=>[...t,newTask]);
            setNewTask("")
        }
    }
    function deleteTask(index){
        const updateTasks=tasks.filter((_,i)=>i!==index);
        setTasks(updateTasks);


    }
    function moveTaskUp(index){
        if(index>0){
            const updateTasks=[...tasks];
            [updateTasks[index],updateTasks[index-1]]=[updateTasks[index-1],updateTasks[index]]
            setTasks(updateTasks);
        }

    }
    function moveTaskDown(index){
        if(index<tasks.length-1){
            const updateTasks=[...tasks];
            [updateTasks[index],updateTasks[index+1]]=[updateTasks[index+1],updateTasks[index]]
            setTasks(updateTasks);
        }

    }
    function handkeydown(enevt){
        if(enevt.key==='Enter'){
            addTask()
        }
    }
    return(
        <div className="to-do-list">
            <h1>To-Do-List</h1>
            <div>
            <input type="text" 
            placeholder="Enter a task"
            value={newTask}
            onChange={handleInputChange}
            onKeyDown={handkeydown}
            />
            <button className="add-button"
            onClick={addTask}
            >Add</button>
            
        </div>
        <ol>
            {tasks.map((task,index)=><li key={index}><span className="text">{task}</span>
            <button className="delete-button"  onClick={()=>deleteTask(index)}>delete</button>
            <button className="move-button" onClick={()=>moveTaskUp(index)}>up</button>
            <button className="move-button" onClick={()=>moveTaskDown(index)}>Down</button>
            </li>)}
        </ol>
        </div>
    
    )
    
    
}
export default tolist
```



### TodoList(Vue)

```js
<template>
  <div class="todo-app">
    <h2>Vue to-do list</h2>
    <div class="input-container">
      <input v-model="newTask" @keyup.enter="addTadsk" placeholder="添加任务..." />
      <button @click="addTadsk">添加</button>
    </div>
    <ul>
      <li v-for="(task,index) in tasks" :key="index" :class="{complate:task.complate}">
        <input type="checkbox" v-model="task.complate"/>
        <span>{{ task.text }}</span>
        <button @click="removeTask(index)">删除</button>
      </li>
    </ul>
  </div>
</template>
<script>
import { ref } from 'vue';
export default{
  setup(){
    const newTask=ref("");
    const tasks=ref([])

  const addTadsk=()=>{
    if(newTask.value.trim()){
      tasks.value.push({text:newTask.value,complate:false});
      newTask.value="";
    }
  };
  const removeTask=(index)=>{
     tasks.value.splice(index,1);
  };
  return {newTask,tasks,addTadsk,removeTask};
  },
};
</script>

<style scoped>
.todo-app{
  max-width: 400px;
  margin: 0 auto;
  text-align: center;
  font-family: sans-serif;
}
.input-container{
  margin-bottom: 10px;
}
input{
  padding: 5px;
  margin-right: 5px;
}
button{
  padding: 5px 10px;
  cursor: pointer;
}
ul{
  list-style: none;
  padding: 0;
}
li{
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px;
  border-bottom: 1px solid #ccc;
}
.complete span{
  text-decoration: line-through;
  color: gray;
}
</style>
```



### **实现Promise.all**

**题目描述**：Promise.all()静态方法接受一个Promise可迭代对象作为输入，并返回一个Promise.

当所有的输入都被兑现时，返回的Promise也将被兑现（即时传入的是一个空的可迭代对象），并返回一个包含所有兑现值的数组

如果输入的任何Promise被拒绝，则返回的Promise将被拒绝，并带有第一个被拒绝的原因

**示例代码**

```js
const promise=()=>{
    return new Promise((reslove,reject)=>{
        if(proms==null||typeof proms[Symbol.iterator]!=='function'){
            throw new TypeError("proms must be an iterable");
        }
        proms=[...proms];
        if(proms.length===0) resolve([]);
        let count=0;
        const result=[];
        proms.forEach((prom,index)=>{
            Promise.resolve(prom)
            .then((res)=>{
                result[index]=res;
                if(++count===proms.length) resolve(result);
            })
            .catch(reject);
        });
    });
};
```





### **防抖**

题目描述

实现一个防抖函数，事件触发后等待一段时间后在执行回调函数，如果在等待期间内再次触发了同一事件，则重新计时，以免回调函数的多次执行。

**示例代码**

setTimeout回调函数执行时，this指向window,需要记录原函数的this.

为了支持回调函数的参数传递，使用...aggs获取此参数并利用apply传递参数。

```js
//js
const debounce=(fn,wait)=>{
    let timer;
    return function(...args){
        const context=this;
        clearTimeout(timer);
        timer=setTimeout(()=>{
            fn.apply(context,args);
        },wait);
    }
}

//Ts
function debounce<T extends (...args:any[])=>void>(
 func:T,
 wait:number
):(...args:Parameters<T>)=>void{
    let timout:ReturnType<typeof setTimeout>|underfined;
    return function (...args:Parameters<T>):void{
        const context=this;
        clearTimeout(timeout!);
  timeout=setTimeout(()=>{
func.apply(this,args);
  },wait)
  };
}

//使用示例
<body>
    <button onClick="handleClick()">Click</button>
</body>
<script>
   const debounce=(fn,wait)=>{
       let timer;
       return function(...args){
           const context=this;
           clearTimeout(timer);
           timer=setTimeout(()=>{
               fn.apply(this,args);
           },wait);
       };
   };
  const handleClick=debounce(()=>{
      console.log("click");
})
</script>
```



**应用场景**

输入框展示搜素建议：当用户在输入框中连续输入时，只是用户停止输入后发送请求

窗口大小变化(resize)事件：当用户调整窗口大小时，只在停止调整后执行布局计算，避免页面抖动。



### **节流**

题目描述

实现一个节流函数，在一定时间内，时间多次触发只执行了一次回调函数，不论时间触发多频繁，都会按照固定的时间间隔执行。

示例代码

```js
//时间戳版本
const throttle=(fn:Function,wait=0)=>{
    let lastTime=0;
    return function(...args:any[]){
        const now=Date.now();
        if(now-lastTime>=wait){
            fn.apply(this,args);
            lastTime=now;
        }
    };
};

//setTimeout版本
const throttle=(fn:Function,wait=0)=>{
    let isThrottle=false;
    return function (...args:any[]){
        if(!isThrottle){
            isThrottle=true;
            fn.apply(this,args);
            setTimeout(()=>(isThrottle=false),wait)
    }
    }
}
//使用示例
<body>
    <div style="height:200vh;background-color:lightblue"></div>
</body>
<script>
    const throttle=(fn,wait)=>{
        //实现略
    }
    const handleScroll=(e)=>{
        console.log(e.target.scrollingElement.scrollTop);
    };
  const throttleHandleScroll=throttle(handleScroll,1000);
document.addEventListener("scroll",throttleHandleScroll);
</script>
```

**应用场景**

图片滚动加载：页面滚动时，不断执行图片加载函数（不使用防抖是因为不可能等到用户听停止滚动才加载图片吧）

托拽(touchmove)事件：拖拽元素时，我们能可能需要在拖拽过程中不断计算元素位置，但不希望计算过于频繁



### **深拷贝**

实现一个深拷贝函数，支持拷贝常见的数据类，例如对象，数组，函数，正则，日期等，并且能够处理循坏引用。

示例代码

使用weakMap作为哈希表，记录已经拷贝过的对象，避免循环引用导致的栈溢出

对于特殊的数据类型，例如Date\RegExp,直接创建新的实列

```js
//便捷版本
function deepCloneEasy<T>(obj:T):T{
    //不能处理函数，正则，underfined.循环引用
    return JSON.parse(JSON.string(obj));
}

//顺便复习一下浅拷贝
//1、Object.assign
//2、扩展运算符

//工具函数
function isObject(value){
  const TYValue = typeof value;
  return (value !== null) && (TYValue === "object" || TYValue === "function")
}

function JLDeepClone(originValue, map = new WeakMap()){
  // 判断是否为Set类型
  if(originValue instanceof Set){
    return new Set([...originValue]);
  }

  // 判断是否为Map类型
  if(originValue instanceof Map){
    return new Map([...originValue])
  }

  // 判断是否为函数类型
  if(typeof originValue === "function"){
    return originValue;
  }

  // 判断是否为symbol类型
  if(typeof originValue === "symbol"){
    return Symbol(originValue.description);
  }

  //判断是否为数组类型
  const newObj = Array.isArray(originValue) ? [] : {};
  map.set(originValue, newObj);
  for(const key in originValue){
    newObj[key] = JLDeepClone(originValue[key])
  }

  // 判断是否为对象类型
  if(!isObject(originValue)){
    return originValue
  }

  // 循环引用
  if(map.has(originValue)){
    return map.get(originValue)
  }

  // 将symbol的key特殊处理
  const symbolKeys = Object.getOwnPropertySymbols(originValue);
  for(const sKey of symbolKeys){
    newObj[sKey] = JLDeepClone(originValue[sKey], map);
  }
  return newObj;
}

```



### **函数柯里化**

题目描述：实现一个柯里化函数，支持多参数传递，例如curry(fn)(a)(b)(c)

柯里化将一个多参数函数转换为一系列函数，这些函数每次接收一个或多个参数，直到所有参数都被提供为止

柯里化的主要作用是参数复用和延迟执行，之前传递的参数可以在后续的调用中复用

示例代码

```js
const curry=(fn,...args)=>{
    return args.length>=fn.length?fn(...args):(...args)=>curry(fn,...args,..._args);
};

//使用示例
const saySomething=(name,str)=>console.log(`${name} says:${str}`);
const tomSay=curry(saySomething,'Tom');
tomSay("hello");
//实现add(1)(2)(3)输出6的函数
const add=(a,b,c)=>a+b+c;
const addCurry=curry(add);
consol.log(addCurry(1)(2)(3));
```



### **并发请求控制**

实现一个PromisePoo;类，限制并发请求的数量

```js
class PromisePool{
    constructor(capacity){
        this.capacity=capacity;
        this.tasks=[];
        this.running=0;
    }
    add(fn){
        return new Promise((reslve,reject)=>{
            this.tasks.push({
                fn,
                resolve,
                reject,
            });
            this._run();
        });
    }
    _run(){
        while(this.tasks.length&&this.running<this.capacity){
            const {fn,resolve,reject}=this.tasks.shift();
            this.running++;
            fn()
            .then(resolve,reject)
            .finally(()=>{
                this.running--;
                this._run();
            });
        }
    }
}
const sleep=(time)=>new Promise((resolve)=>setTimeout(resolve,time));
const addTask=(time,str)=>{
    pool
    .add(()=>sleep(time))
    .then(()=>{
        console.log(str);
    });
};
const pool=new PromisePool(2);
addTask(10000,'1');
addTask(5000,'2');
addTask(3000,'3');
addTask(4000,'4');
addTask(5000,'5');

//2 3 1 4 5
```



### ES5实现继承

**原型链的核心只需要记住三点：**

1、每个对象都有`_proto_`属性,该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找

2、构造函数的`prototype`属性也指向实例的原型对象

3、原型对象的`constructor`属性也指向构造函数



#### 原型链继承

原型链继承很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承

```js
function Parent(){
    this.name='戴森球'
}
//父类的原型方法
Parent.prototype.getName=function(){
    return thid.name;
}
function Child(){}
//让子类的原型对象指向父类实例，这样一来在Child实例中找不到的属性和方法就会在原型对象（父类实例）上寻找
Child.prototype=new Parent()
//根据原型链的规则，顺便绑定一下constructor,这一步不影响继承，只是再用到constructor时会用到
Child.prototyp.constructor=Child

const child=new Child()
child.name
child.getName()

```

**原型链继承的缺点：**

由于所有的Child实例原型都指向同一个Parnet实例，因此对某个实例的父引用类型变量修改影响所有的Child实例

在创建子类实列时，无法向父类构造传参，即没有实现super()的功能



#### 构造函数继承

构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的this,让父类的构造函数把成员属性和方法都挂在子类的this上去，这样即能避免实例之间共享一个原型实例，又能向父类构造方法传参

```js
function Parent(name){
    this.name=[name]
}
Parent.prototype.getName=function(){
    return this.name
}
function Child(){
    //执行父类构造方法并绑定到子类的this,使得父类中的属性能够赋到子类的this上
    Parent.call(this,'zhangsan')
}
const child1=new Child()
const child2=new child()
child1.name[0]='foo'
console.log(child1.name)
console.log(child2.name)
child2.getName() //报错，找不到getName(),构造函数继承的方式找不到父类原型上的属性和方法
```



**构造函数继承的缺点**

继承不到父类原型上的属性和方法

#### 组合式继承

既然原型链继承和构造函数继承各有互补的优缺点，那么我们为什么不组合起来使用呢

```js
function Parent(name){
    thi.name=[name]
}
Parent.prototype.getName=function(){
    return this.name
}
function Child(){
    Parent.call(this,'zhangsan')
}
Child.prototype=new Parent()
Child.prototype.constructor=Child

const child1=new Child()
const child2=new Child()
child1.name[0]='foo'
console.log(child1.name)
console.log(child2.name)
child2.getName()
```



组合式继承的缺点

每次创建子类实例都执行了两次构造函数，虽然这并不影响对父类的继承，丹子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅



#### 寄生式组合继承

为了解决构造函数被执行两次的问题，我们将指向父类实例改为指向父类原型，减去一次构造函数的执行

```js
function Parent(){
    this.name=[name]
}
Parent.prototype.getName=function(){
    return this.name
}
function Child(){
    Parent.call(this,'zhangsan')
}

//将父类实例改为父类原型
Child.prototype=Parent.prototype
Child.prototype.constructor=Child

const child1=new Child()
const child2=new Child()
child1.name[0]='foo'
console.log(child1.name)
console.log(child2.name)
child2.getName()
```

但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给Child.prototype增加一个getName()方法，那么会导致Parent.prototype也增加或被覆盖一个getName()方法，为了解决这个问题，我们给Parent.prototype做一个浅拷贝

```js
function Parent(){
    this.name=[name]
}
Parent.prototype.getName=function(){
    return this.name
}
functuion Child(){
    Parent.call(this.'zhangsan')
}
Child.prototype=Object.creat(Parent.prototype)
Child.prototype.constructor=Child

const child=new Child()
conts parent=new Parent()
child.getName()
parent.getName()
```



### ES6中的class继承

ES6中引入了calss关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法，这比ES5的通过修改原型链实现继承，要清晰和方便很多，需要注意是，class关键字只是原型的语法糖，javascript继承仍然是基于原型实现的

```js
class pet{
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    showName(){
        console.log('调用父类的方法');
        console.log(this.name,this.age);
    }
}
class Dog extends Pet{
    constructor(name,age,color){
        super(name,age);
        this.color=color;
    }
    showName(){
        console.log('调用子类的方法');
        console.log(this.name,this.age,this.color);
    }
}
```



### 实现new关键字

new是一个用于对象实例的关键字，他用于调用构造函数，并返回一个新的对象

使用new关键字创建的对象，就可以访问构造函数中定义的属性和方法以及构造函数原型链中的属性和方法

**实现原理：**

1、创建一个新的空对象

2、将新创建的对象的`_proto_`属性指向构造函数的`prototype`属性

3、将构造函数的this关键字指向新创建的对象

4、执行构造函数中的代码，给这个空对象添加属性和方法。

5、如果构造函数没有显式返回一个空对象，则返回新创建的对象

```js
function myNew(constructor,...args){
    const obj={};
    Object.setPrototypeOf(obj,constructor.prototype);
    const result=constructor.apply(obj,args);
    return Object.prototype.toString.call(result)==='[Object Object]'?result:obj;
}
```



### 实现call方法

```js
// 实现 call 方法
Function.prototype.myCall = function (context, ...args) {
  // 如果 context 参数为空，则默认为 window 对象
  context = context || window;
  // 使用 Symbol 函数创建一个唯一的标识符
  const fnSymbol = Symbol();
  // 将原始函数存储为 context 对象的属性
  context[fnSymbol] = this;
  // 调用函数并将结果存储在 result 变量中
  const result = context[fnSymbol](...args);
  // 删除 context 对象的属性
  delete context[fnSymbol];
  // 返回函数的结果
  return result;
};

// 实现 apply 方法
Function.prototype.myApply = function (context, args) {
  // 如果 context 参数为空，则默认为 window 对象
  context = context || window;
  // 使用 Symbol 函数创建一个唯一的标识符
  const fnSymbol = Symbol();
  // 将原始函数存储为 context 对象的属性
  context[fnSymbol] = this;
  // 调用函数并将结果存储在 result 变量中
  const result = context[fnSymbol](...args);
  // 删除 context 对象的属性
  delete context[fnSymbol];
  // 返回函数的结果
  return result;
};

// 实现 bind 方法
Function.prototype.myBind = function (context, ...args) {
  // 将 this 存储在 fn 变量中
  const fn = this;
  // 返回一个新的函数，该函数将传入的参数与新函数的参数合并，并在新的上下文中使用 apply 调用原始函数
  return function (...newArgs) {
    return fn.apply(context, [...args, ...newArgs]);
  };
};

```



### 常见的排序算法

```js
/**
快速排序
*/
function sort(array){
    if(!array) throw Error('arrar不存在');
    const n=array.length;
    if(!n) return array;
    const midIndex=Math.floor(n/2);
    const midVal=array[midIndex];
    const left=[];
    const right=[];
    for(let i=0;i<n;i++){
        if(i===midIndex) continue;
        array[i]<midVal?left.push(array[i]):right.push(array[i]);
    }
    return sort(left).concat([miodVal],sort(right));
}
```



### CSS实现三角型

```js
//倒三角
.triangle {
    width: 0;
    height: 0;
    border-top: 50px solid skyblue;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
}

//等边三家
.triangle {
		width: 0;
		height: 0;
		border-left: 69px solid transparent;  
		border-right: 69px solid transparent;  
		border-bottom: 120px solid skyblue; 
}

```



### 数组扁平化

```js
//递归实现
let arr=[1,[2,[3,4,5]]];
function flatten(arr){
    let result=[];
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
            result=result.concat(flatten(arr[i]));
        }
        else{
            result.push(arr[i]);
        }
}
    return result;
}
console.log(flatten(a));

//reduce实现
let arr=[1,[2,[3,4]]];
function flatten(arr){
    return arr.reduce(function(pre,cur){
        return pre.concat(Array.isArray(cur)?flatten(cur):cur)
    },[])
}

//扩展运算符实现
let arr=[1,[2,[3,4]]];
function flatten(arr){
    while(arr.some(i=>Array.isArray(i))){
        arr=[].concat(...arr);
    }
    return arr;
}
console.log(flatten(arr));

//split+toString
let arr=[1,[2,[3,4]]];
function flatten(arr){
    return arr.toString().split(',').map(i=>Number(i));
}
console.log(flatten(arr));

//Array.prototype.flat
let arr=[1,[2,[3,4]]];
function flatten(arr){
    return arr.flat(Infinity);
    //参数Infinity表示完全展开，使用起来非常方便
}
console.log(flatten(arr));
```



### 手写AJAX

**Promise版本**

```js
const getJSON=function(url){
    return new Promise((resolve,reject)=>{
        const xhr=new XMLHttpRequest();
        xhr.open('GET',url,false);
        xhr.setRequestHeader('Content-Type','application/json');
        xhr.onreadystatechange=function(){
            if(xhr.readyState!==4) return;
            if(xhr.status===200||xhr.status===304){
                resolve(xhr.responseText);
            }else{
               reject(new Error(xhr.responseText));
            }
        };
        xhr.send();
    });
};


function ajax(option){
    var str=objToString(option.data);
    var xmlhttp,timer;
    if(window.XMLHttpRequest){
        xmlhttp=new XMLHttpRequest();
    }else{
        xmlhttp=new ActiveXObject('Microsoft.XMLHTTP');
    }
    if(option.type.toLowerCase()==='get'){
        xmlhttp.open(option.type,option.url+'?t='+str,true);
        xmlhttp.send();
    }else{
        xmlhttp.open(option.type,option.url,true);
        xmlhttp.setRequestHeader('Content-type','application/x-www-form-urlencoded');
        xmlhttp.send(str);
    }
    xmlhttp.onreadystatechange=function(){
        clearInterval(timer);
        if(xmlhttp.readyState===4){
            if(xmlhttp.status>=200&&xmlhttp.status<300||xmlhttp.status==304){
                option.success(xmlhttp);
            }else{
                option.error(xmlhttp);
            }
        }
    }
    function objToString(data){
        data.t=new Date().getTime();
        var res=[];
        for(var key in data){
            res.push(encodeURIComponent(key)+'='+encodeURIComponent(data[key]));
        }
        return res.join('&');
    }
    if(option.timeout){
        timer=setInterval(function(){
            xmlhttp.abort(); //中断请求
            clearInterval(timer);
        },timeout);
    }
}

```

以上内容参考 ，感谢各位作者

- [zbwer's blog](https://blog.zbwer.work/Notes/Interviews/%E6%89%8B%E5%86%99%E4%B8%8E%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F%E9%A2%98.html)
- [CSDN](https://blog.csdn.net/weixin_45844376/article/details/105677231)
- [掘金1](https://juejin.cn/post/7207587475169476667)
- [思否](https://segmentfault.com/a/1190000040733538)
- [掘金2](https://juejin.cn/post/6998879961935249422)