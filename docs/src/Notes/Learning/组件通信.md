---
updateTime: "2025-04-24 16:07"
desc: "React组件通信&受控组件&非受控组件&样式隔离"
tags: "React基础"
outline: deep
---
## 组件通信

### 父传子

React使用props来互相通信，每个父组件都可以提供props给他的子组件，从而将一些信息传递给他，Props可能让你想起HTML属性，但你可以通过它们传递任何JavaScript值，包括对象，数组和函数以及HTML元素，这样可以使我们的组件更加灵活

**父组件**

```tsx
import './App.css'
import Card from './components'
function App() {


  return (
    <>
     <div>hello world</div>
     <Card
      title='戴森球集团'
      id={1}
      obj={{a:1,b:2}}
      arr={[1,2,3]}
      cb={(a:number,b:number)=>a+b}
      empty={null}
      />
     <Card />
    </>
  )
}

export default App

```
```md
父向子组件传递proprs，支持的类型如下

1. string title={'测试'}
2. number id={1}
3. boolean isGirl={false}
4. null empty={null}
5. undefined empty={undefined}
6. object obj={{a:1,b:2}}
7. array arr={[1,2,3]}
8. function cd={(a:number,b:number)=>a+b}
9. JSX.Element element{<div>测试</div>}
```
**子组件**

```tsx
import './index.css'
interface Props{
    title?:string
    id?:number
    obj?:{
        a:number
        b:number
    }
    arr?:number[]
    cb?:(a:number,b:number)=>number
    empty?:null
    
}

//默认内容
const defaultProps:Partial<Props>={
    title:'默认标题'
}
const Card:React.FC<Props>=(props)=>{
    const {title}={...defaultProps,...props}
    
    return (
       <div className='card'>
          <header>
            <div>{title}</div>
            <div>{props.id}</div>
            <div>{props.obj&& props.obj.a}</div>
            <div>{props.arr}</div>
          </header>
          <main>
            内容区域
          </main>
          <footer>
          
            <button onClick={()=>window.onShow()}>确认</button>
            <button>取消</button>

          </footer>
       </div>
    )
}
export default Card;
```

可以定义默认值，比如父组件没有传递title时，设置默认title,用`defaultProps`进行默认值赋值，最后把defaultProps 和 props 合并，注意顺序要先写defaultProps，再写props 因为props会覆盖defaultProps的值。`Partial<T>` 是一个内置的工具类型，其作用是把类型 `T` 里的所有属性都转换为可选属性。



### 子传父

React没有像Vue那样的emit派发时间，所以我们用回调函数模拟emit派发事件

父组件传递函数过去，其本质就是录用函数的回调

**父组件**

```tsx
import Test from './components/Test'
function App(){
    const fn=(params:string)=>{
        console.log('子组件出发了父组件的事件',params)
    }
    return (
        <>
        <Test callback={fn}></Test>
        <>
    )
}
```

子组件接受函数，并且在对应的事件调用函数，回调参数回去

**子组件**

```tsx
import React from 'react'
interface Props{
    callback:(params:string)=>void
    children?:React.ReactNode
}
const Test:React.FC<Props>=>(props)=>{
    return <div>
        <button onClick={()=>props.callback('我是戴森球')}>派发事件</button>
       </div>
}
export default Test;
```



### 兄弟组件一

定义两个组件放在一起作为兄弟组件，其原理就是发布订阅设计模式，原生浏览器已经实现了这个模式

**App.js**

```tsx
import './App.css'
import Test from './components/test1'
import Test2 from './components/Test'
function App() {


  return (
    <>
     <div>hello world</div>
      <Test></Test>
      <Test2></Test2>
    </>
  )
}

export default App

```

**test1.tsx**

```tsx
import React from "react";
const Test:React.FC=(props)=>{
    const event=new Event('on-card')
    const clickTap=()=>{
        console.log(event)
        event.params={name:'戴森球集团'}
        window.dispatchEvent(event)
    }
    return <div>
        <button onClick={clickTap}>派发事件</button>
    </div>
}
declare global{
    interface Event{
        params:any
    }
}

export default Test
```

 **test.tsx**

```tsx
import './index.css'
export default function Test2(){
    window.addEventListener('on-card',(e)=>{
        console.log(e.params,'触发了')
    })
    return <div className='card'></div>
}
```



### 兄弟组件二

兄弟组件之间的数据传递，可以利用组件的Props以及Props回调函数来进行，而这种使用方法通信的前提是：必须要有共同的父组件

**Test.tsx**

```tsx
interface ChildFProps{
    update:(title:string)=>void
}
const ChildF:React.FC<ChildFProps>=({update})=>{
 return <button className="border:1px solid " onClick={()=>{
    update('abcde')
 }}>点击派发</button>
}
export default ChildF
```

**Test1.tsx**

```tsx
interface ChildGProps{
    title:string
}
const ChildG:React.FC<ChildGProps>=({title})=>{
    return <div>
      <div>收到了Test组件的值{title}</div>  
    </div>
}
export default ChildG;
```

**App.tsx**

```tsx
import './App.css'
import Test1 from './components/test1'
import Test from './components/Test'
import { useState } from 'react'
function App() {
const [updateValue,setUpdateValue]=useState('')
  return (
    <>
     <div>hello world</div>
      <Test update={(v)=>{
        setUpdateValue(v)
      }}></Test>
      <Test1 title={updateValue}></Test1>
    </>
  )
}

export default App

```



### 受控组件/非受控组件

受控组件一般是指表单元素，表单数据由React的State管理，更新数据时，需要手动调用setState()方法，更新数据。因为React没有类似于Vue的v-model，所以需要自己实现绑定事件

为什么需要使用受控组件？

使用受控组件可以确保表单数据与组件状态同步、便于集中管理和验证数据，同时提供灵活的事件处理机制以实现数据格式化和UI联动效果

我们在界面的输入框中输入内容，这时候你会发现这个value是只读的，无法修改，还会报错

**案例**

```tsx
import React, { useState } from "react";
const Demo:React.FC=()=>{
    const [value,setValue]=useState('')
    return (
        <div>
            <input type="text" onChange={} value={value} />
            <div>{value}</div>
        </div>
    )
}
export default Demo;
```

当用户输入内容时，value不会自动更新，这时候就需要我们手动实现一个onChange事件来更新value。

**受控组件如下代码所示**

```tsx
import React, { useState } from "react";
const Demo:React.FC=()=>{
    const [value,setValue]=useState('')
    const handleChange=(e:React.ChangeEvent<HTMLInputElement>)=>{
        setValue(e.target.value)
    }
    return (
        <div>
            <input type="text" onChange={handleChange} value={value} />
            <div>{value}</div>
        </div>
    )
}
export default Demo;
```

其实就是实现了以哦个类似于Vue的v-model的机制，通过onChange事件来更新value,这样就变成了受控组件



**非受控组件**

非受控组件指的是该表单不受React的Staet管理，表单数据由DOM管理，通过useRef()来获取表单元素的值。

我们使用defaultValue来设置表单的默认值，但是你要想实时获取值，就需要使用useRef()来获取表单元素的值，跟操作DOM一样

```tsx
import React,{useState,useRef} from 'react'
const Demo:React.FC=()=>{
    const value='戴森球'
    const inputRef=useRef<HTMLInputElement>(null)
    const handleChange=()=>{
        console.log(inputRef.current?.value);
    }
    return (
        <div>
          <input type="text" ref={inputRef} defaultValue={value} onChange={handleChange}/>
        </div>
    )
  
}
export default Demo
```



### Suspense

Suspense是一种异步渲染机制，其核心理念是在组件加载或数据获取过程中，先展示一个占位符，从而实现更自然流畅的用户界面更新体验

**应用场景**

异步组件加载：通过代码分包实现组件的按需加载，有效减少首屏加载时的资源体积，提升应用性能

异步加载数据：在数据请求过程中展示优雅的过度状态（如loading动画，股架屏等）为用户提供更流畅的交互体验

异步图片资源加载：智能管理图片资源的加载状态，在图片完全加载前显示占位符内容，确保页面布局稳定，提升用户体验

**用法**

```tsx
<Suspense fallback={<div>Loading...</div>}>
    <AsyncCOMPONENT/>
</Suspense>
```

**参数**

- fallback:指定在组件加载或数据获取过程中展示的组件或元素
- children:指定要异步加载的组件或数据



### css modules

因为React没有Vue的Scoped,但是Reac又是单页面应用，所以需要一种方式来解决css的样式冲突问题，也就是把每个组件的样式做成单独的作用域，实现样式隔离，而css modules就是一种解决方案，但是我们需要借助一些工具来实现，比如webpack,postcss,css-loader,vite等。

如何在Vite中使用css modules

> css modules可以配合各种css预处理器使用，例如less,sass,stylus等

在Vite中 css Modules是开箱即用的，只需要把文件名设置为`xxx.module.css/less/scss/stylus`

**例如**

**src/components/Button/index.modules.scss**

```scss
.button{
    color:red;
}
```

**src/components/Button/index.tsx**

```tsx
//使用方法，直接引入即可
import styles from './index.module.scss';
const Test=()=>{
    return <button className={styles.button}>按钮</button> 
}
export default Test;
```

编译结果，可以看到button类名被编译成了button_pmkzx_6,这就是css modules的实现原理，通过在类名前添加一个唯一的哈希值，来实现样式隔离

```tsx
<button class='button_pmkzx_6'>按钮</button>
```

修改css modules规则

在vite.config.ts中配置css modules的规则

```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  css:{
   modules:{
    localsConvention:'camelCase' //camelCase 会把非驼峰的命名转为驼峰，并保留之前的类名
    localsConvention:'camelCaseOnly' //camelCaseOnly 只会把非驼峰的命名转为驼峰，并删除之前的类名。
    localsConvention:'dashes' //dashes 会保留原始的类名
    localsConvention:'dashesOnly' // dashesOnly 会删除原始的类名。
    generateScopedName: '[local]_[hash:base64:5]' // 只保留类名和哈希值
    // 或者
    generateScopedName: '[hash:base64:8]' // 只使用哈希值
    // 或者
    generateScopedName: '[name]_[local]' // 只使用文件名和类名，没有哈希
    // 或者
    generateScopedName: '[local]--[hash:base64:4]' // 自定义分隔符

   }
  },
  plugins: [react()],
})

```

**维持类名**

意思是说在样式文件的某些样式下，不希望被编译成css modules,可以设置为global,例如：

**index.module.scss**

```scss
.app{
  background: red;
  width: 200px;
  height: 200px;
  :global(.button){
    background: blue;
    width: 100px;
    height: 100px;
  }
}
```

**test.tsx**

```tsx
//在使用的时候，就可以直接使用原始的类名 button
import styles from './index.module.scss';
const Test: React.FC = () => {
  return (
    <>
      <div className={styles.app}>
        <button className='button'>按钮</button>
      </div>
    </>
  );
}

export default Test
```

